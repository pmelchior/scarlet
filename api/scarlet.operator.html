<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>scarlet.operator &#8212; scarlet  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="canonical" href="api/api/scarlet.operator.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="scarlet.parameter" href="scarlet.parameter.html" />
    <link rel="prev" title="scarlet.observation" href="scarlet.observation.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo"/>
            </a></p>
<h3><a href="../index.html">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0-quickstart.html">Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../1-concepts.html">Core Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="scarlet.html">API Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="scarlet.bbox.html">scarlet.bbox</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.blend.html">scarlet.blend</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.cache.html">scarlet.cache</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.component.html">scarlet.component</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.constraint.html">scarlet.constraint</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.detect.html">scarlet.detect</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.display.html">scarlet.display</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.fft.html">scarlet.fft</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.frame.html">scarlet.frame</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.initialization.html">scarlet.initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.interpolation.html">scarlet.interpolation</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.measure.html">scarlet.measure</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.model.html">scarlet.model</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.morphology.html">scarlet.morphology</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.observation.html">scarlet.observation</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">scarlet.operator</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.parameter.html">scarlet.parameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.prior.html">scarlet.prior</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.psf.html">scarlet.psf</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.renderer.html">scarlet.renderer</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.source.html">scarlet.source</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.spectrum.html">scarlet.spectrum</a></li>
<li class="toctree-l2"><a class="reference internal" href="scarlet.wavelet.html">scarlet.wavelet</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../regression.html">Regression Testing</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-scarlet.operator">
<span id="scarlet-operator"></span><h1>scarlet.operator<a class="headerlink" href="#module-scarlet.operator" title="Permalink to this heading">¶</a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.diagonalizeArray">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">diagonalizeArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float64'&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#diagonalizeArray"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.diagonalizeArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array to a matrix that compares each pixel to its neighbors
Given an array with length N, create an 8xN array, where each row will be a
diagonal in a diagonalized array. Each column in this matrix is a row in the larger
NxN matrix used for an operator, except that this 2D array only contains the values
used to create the bands in the band diagonal matrix.
Because the off-diagonal bands have less than N elements, <code class="docutils literal notranslate"><span class="pre">getOffsets</span></code> is used to
create a mask that will set the elements of the array that are outside of the matrix to zero.
<code class="docutils literal notranslate"><span class="pre">arr</span></code> is the vector to diagonalize, for example the distance from each pixel to the peak,
or the angle of the vector to the peak.
<code class="docutils literal notranslate"><span class="pre">shape</span></code> is the shape of the original image.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.diagonalsToSparse">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">diagonalsToSparse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diagonals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float64'&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#diagonalsToSparse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.diagonalsToSparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a diagonalized array into a sparse diagonal matrix
<code class="docutils literal notranslate"><span class="pre">diagonalizeArray</span></code> creates an 8xN array representing the bands that describe the
interactions of a pixel with its neighbors. This function takes that 8xN array and converts
it into a sparse diagonal matrix.
See <cite>diagonalizeArray</cite> for the details of the 8xN array.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.find_Q">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">find_Q</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Vs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#find_Q"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.find_Q" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds a Q that is within the solution space that can act as an appropriate target
(could be rigorously constructed later)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.find_relevant_dim">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">find_relevant_dim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#find_relevant_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.find_relevant_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds a dimension relevant to the problem by ‘raycasting’ from Y to Q</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.getOffsets">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">getOffsets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#getOffsets"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.getOffsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the offset and slices for a sparse band diagonal array
For an operator that interacts with its neighbors we want a band diagonal matrix,
where each row describes the 8 pixels that are neighbors for the reference pixel
(the diagonal). Regardless of the operator, these 8 bands are always the same,
so we make a utility function that returns the offsets (passed to scipy.sparse.diags).
See <cite>diagonalizeArray</cite> for more on the slices and format of the array used to create
NxN operators that act on a data vector.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.getRadialMonotonicWeights">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">getRadialMonotonicWeights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'flat'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#getRadialMonotonicWeights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.getRadialMonotonicWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the weights used for the Radial Monotonicity Operator
This version of the radial monotonicity operator selects all of the pixels closer to the peak
for each pixel and weights their flux based on their alignment with a vector from the pixel
to the peak. In order to quickly create this using sparse matrices, its construction is a bit opaque.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.get_center">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">get_center</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#get_center"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.get_center" title="Permalink to this definition">¶</a></dt>
<dd><p>Search around a location for the maximum flux</p>
<p>For monotonicity it is important to start at the brightest pixel
in the center of the source. This may be off by a pixel or two,
so we search for the correct center before applying
monotonic_tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image: array-like</strong></dt><dd><p>The image of the source.</p>
</dd>
<dt><strong>center: (int, int)</strong></dt><dd><p>The suggested center of the source.</p>
</dd>
<dt><strong>radius: int</strong></dt><dd><p>The number of pixels around the <cite>center</cite> to search
for a higher flux value.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>new_center: (int, int)</dt><dd><p>The true center of the source.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.proj">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the projection of A onto the hyper-plane defined by B</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.proj_dist">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">proj_dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#proj_dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.proj_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns length of projection of A onto B</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.project_disk_sed">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">project_disk_sed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bulge_sed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disk_sed</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#project_disk_sed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.project_disk_sed" title="Permalink to this definition">¶</a></dt>
<dd><p>Project the disk SED onto the space where it is bluer</p>
<p>For the majority of observed galaxies, it appears that
the difference between the bulge and the disk SEDs is
roughly monotonic, making the disk bluer.</p>
<p>This projection operator projects colors that are redder onto
the same difference in color as the previous wavelength,
similar to the way monotonicity works for the morphological
<cite>S</cite> matrix of the model.</p>
<p>While a single iteration of this model is unlikely to yield
results that are as good as those in <cite>project_disk_sed_mean</cite>,
after many iterations it is expected to converge to a better value.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.project_disk_sed_mean">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">project_disk_sed_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bulge_sed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disk_sed</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#project_disk_sed_mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.project_disk_sed_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Project the disk SED onto the space where it is bluer</p>
<p>For the majority of observed galaxies, it appears that
the difference between the bulge and the disk SEDs is
roughly monotonic, making the disk bluer.</p>
<p>This projection operator projects colors that are redder
than other colors onto the average SED difference for
that wavelength. This is a more accurate SED than
<cite>project_disk_sed</cite> but is more likely to create
discontinuities in the evaluation of A, and should
probably be avoided. It is being kept for now to record
its effect.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.prox_cone">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">prox_cone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#prox_cone"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.prox_cone" title="Permalink to this definition">¶</a></dt>
<dd><p>Exact projection of components of X onto cone defined by Gx &gt;= 0</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.prox_kspace_symmetry">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">prox_kspace_symmetry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#prox_kspace_symmetry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.prox_kspace_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Symmetry in Fourier Space</p>
<p>This algorithm by Nate Lust uses the fact that throwing
away the imaginary part in Fourier space leaves a symmetric
soution in real space. So <cite>X</cite> is transformed to Fourier space,
shifted by the fractional amount <cite>shift=(dy, dx)</cite>,
the imaginary part is discarded, shited back to its original position,
then transformed back to real space.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.prox_monotonic_mask">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">prox_monotonic_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#prox_monotonic_mask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.prox_monotonic_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply monotonicity from any path from the center</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>X: array-like</strong></dt><dd><p>The input image that the mask is created for.</p>
</dd>
<dt><strong>step: `int`</strong></dt><dd><p>This parameter is ignored for this prox, but is required by <cite>prox_min</cite>.</p>
</dd>
<dt><strong>center: `tuple` of `int`</strong></dt><dd><p>The location of the center of the mask.</p>
</dd>
<dt><strong>center_radius: `float`</strong></dt><dd><p>Radius from the center pixel to search for a better center
(ie. a pixel in <cite>X</cite> with higher flux than the pixel given by</p>
<blockquote>
<div><p><cite>center</cite>).</p>
</div></blockquote>
<p>If <cite>center_radius == 0</cite> then the <cite>center</cite> pixel is assumed to be correct.</p>
</dd>
<dt><strong>variance: `float`</strong></dt><dd><p>The average variance in the image.
This is used to allow pixels to be non-monotonic up to <cite>variance</cite>,
so setting <cite>variance=0</cite> will force strict monotonicity in the mask.</p>
</dd>
<dt><strong>max_iter: int</strong></dt><dd><p>Maximum number of iterations to interpolate non-monotonic pixels.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.prox_sdss_symmetry">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">prox_sdss_symmetry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#prox_sdss_symmetry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.prox_sdss_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>SDSS/HSC symmetry operator</p>
<p>This function uses the <em>minimum</em> of the two
symmetric pixels in the update.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.prox_soft_symmetry">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">prox_soft_symmetry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strength</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#prox_soft_symmetry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.prox_soft_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Soft version of symmetry
Using a <cite>strength</cite> that varies from 0 to 1,
with 0 meaning no symmetry enforced at all and
1  being completely symmetric, the user can customize
the level of symmetry required for a component</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.prox_uncentered_symmetry">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">prox_uncentered_symmetry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'kspace'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strength</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#prox_uncentered_symmetry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.prox_uncentered_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Symmetry with off-center peak</p>
<p>Symmetrize X for all pixels with a symmetric partner.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>X: array</strong></dt><dd><p>The parameter to update.</p>
</dd>
<dt><strong>step: `int`</strong></dt><dd><p>Step size of the gradient step.</p>
</dd>
<dt><strong>center: tuple of `int`</strong></dt><dd><p>The center pixel coordinates to apply the symmetry operator.</p>
</dd>
<dt><strong>algorithm: `string`</strong></dt><dd><p>The algorithm to use for symmetry.
* If <cite>algorithm = “kspace” then `X</cite> is shifted by <cite>shift</cite> and</p>
<blockquote>
<div><p>symmetry is performed in kspace. This is the only symmetry algorithm
in scarlet that works for fractional pixel shifts.</p>
</div></blockquote>
<ul class="simple">
<li><p>If <cite>algorithm = “sdss” then the SDSS symmetry is used,
namely the source is made symmetric around the `center</cite> pixel
by taking the minimum of each pixel and its symmetric partner.
This is the algorithm used when initializing an <cite>ExtendedSource</cite>
because it keeps the morphologies small, but during optimization
the penalty is much stronger than the gradient
and often leads to vanishing sources.</p></li>
<li><p>If <cite>algorithm = “soft” then soft symmetry is used,
meaning `X</cite> will be allowed to differ from symmetry by the fraction
<cite>strength</cite> from a perfectly symmetric solution. It is advised against
using this algorithm because it does not work in general for sources
shifted by a fractional amount, however it is used internally if
a source is centered perfectly on a pixel.</p></li>
</ul>
</dd>
<dt><strong>fill: `float`</strong></dt><dd><p>The value to fill the region that cannot be made symmetric.
When <cite>fill</cite> is <cite>None</cite> then the region of <cite>X</cite> that is not symmetric
is not constrained.</p>
</dd>
<dt><strong>strength: `float`</strong></dt><dd><p>The amount that symmetry is enforced. If <cite>strength=0</cite> then no
symmetry is enforced, while <cite>strength=1</cite> enforces strict symmetry
(ie. the mean of the two symmetric pixels is used for both of them).
This parameter is only used when <cite>algorithm = “soft”</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>result: <cite>function</cite></dt><dd><p>The update function based on the specified parameters.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.prox_weighted_monotonic">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">prox_weighted_monotonic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'flat'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_gradient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#prox_weighted_monotonic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.prox_weighted_monotonic" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the prox_monotonic operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>neighbor_weight: [‘flat’, ‘angle’, ‘nearest’]</strong></dt><dd><p>Which weighting scheme to average all neighbor pixels towards <cite>center</cite>
as reference for the monotonicty test.</p>
</dd>
<dt><strong>min_gradient: `float`</strong></dt><dd><p>Forced gradient. A <cite>thresh</cite> of zero will allow a pixel to be the
same value as its reference pixels, while a <cite>thresh</cite> of one
will force the pixel to zero.</p>
</dd>
<dt><strong>center: tuple</strong></dt><dd><p>Location of the central (highest-value) pixel.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>result: <cite>function</cite></dt><dd><p>The monotonicity function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.proximal_disk_sed">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">proximal_disk_sed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">peaks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm=&lt;function</span> <span class="pre">project_disk_sed_mean&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#proximal_disk_sed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.proximal_disk_sed" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that each disk SED is bluer than the bulge SED</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.sort_by_radius">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">sort_by_radius</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#sort_by_radius"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.sort_by_radius" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort indices distance from the center</p>
<p>Given a shape, calculate the distance of each
pixel from the center and return the indices
of each pixel, sorted by radial distance from
the center, which need not be in the center
of the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape: `tuple`</strong></dt><dd><p>Shape (y,x) of the source frame.</p>
</dd>
<dt><strong>center: array-like</strong></dt><dd><p>Location of the center pixel.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>didx: <cite>~numpy.array</cite></dt><dd><p>Indices of elements in an image with shape <cite>shape</cite>,
sorted by distance from the center.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.uncentered_operator">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">uncentered_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#uncentered_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.uncentered_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Only apply the operator on a centered patch</p>
<p>In some cases, for example symmetry, an operator might not make
sense outside of a centered box. This operator only updates
the portion of <cite>X</cite> inside the centered region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X: array</strong></dt><dd><p>The parameter to update.</p>
</dd>
<dt><strong>func: `function`</strong></dt><dd><p>The function (or operator) to apply to <cite>X</cite>.</p>
</dd>
<dt><strong>center: tuple</strong></dt><dd><p>The location of the center of the sub-region to
apply <cite>func</cite> to <cite>X</cite>.</p>
</dd>
<dt><strong>`fill`: `float`</strong></dt><dd><p>The value to fill the region outside of centered
<cite>sub-region</cite>, for example <cite>0</cite>. If <cite>fill</cite> is <cite>None</cite>
then only the subregion is updated and the rest of
<cite>X</cite> remains unchanged.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="scarlet.operator.use_relevant_dim">
<span class="sig-prename descclassname"><span class="pre">scarlet.operator.</span></span><span class="sig-name descname"><span class="pre">use_relevant_dim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/scarlet/operator.html#use_relevant_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#scarlet.operator.use_relevant_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses relevant dimension to reduce problem dimensionality (projects everything onto the
new hyperplane</p>
</dd></dl>

</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2018-2024, Fred Moolekamp and Peter Melchior.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.0.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../_sources/api/scarlet.operator.rst"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>